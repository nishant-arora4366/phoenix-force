[
    {
      "function_name": "cancel_slot_reservation",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_slot_id uuid, p_user_id uuid DEFAULT auth.uid()",
      "source_code": "\nDECLARE\n    v_slot RECORD;\nBEGIN\n    -- Get slot details\n    SELECT * INTO v_slot \n    FROM tournament_slots \n    WHERE id = p_slot_id \n    AND tournament_id = p_tournament_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Slot not found'\n        );\n    END IF;\n    \n    -- Check if slot can be cancelled (only pending slots)\n    IF v_slot.status != 'pending' THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Only pending slots can be cancelled',\n            'current_status', v_slot.status\n        );\n    END IF;\n    \n    -- Cancel the slot\n    UPDATE tournament_slots \n    SET \n        player_id = NULL,\n        status = 'empty',\n        requested_at = NULL\n    WHERE id = p_slot_id;\n    \n    RETURN json_build_object(\n        'success', true,\n        'message', 'Slot reservation cancelled',\n        'slot_id', p_slot_id,\n        'tournament_id', p_tournament_id\n    );\n    \nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Failed to cancel slot: ' || SQLERRM\n        );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "cleanup_old_api_analytics",
      "return_type": "void",
      "arguments": "",
      "source_code": "\nBEGIN\n    -- Delete analytics data older than 90 days\n    DELETE FROM public.api_usage_analytics \n    WHERE created_at < NOW() - INTERVAL '90 days';\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "confirm_slot",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_slot_id uuid, p_user_id uuid DEFAULT auth.uid()",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_slot RECORD;\n    v_result JSON;\nBEGIN\n    -- Start transaction\n    BEGIN\n        -- Validate tournament exists and is in correct phase\n        SELECT * INTO v_tournament \n        FROM tournaments \n        WHERE id = p_tournament_id;\n        \n        IF NOT FOUND THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Tournament not found',\n                'tournament_id', p_tournament_id\n            );\n        END IF;\n        \n        -- Get slot details\n        SELECT * INTO v_slot \n        FROM tournament_slots \n        WHERE id = p_slot_id \n        AND tournament_id = p_tournament_id;\n        \n        IF NOT FOUND THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Slot not found',\n                'slot_id', p_slot_id\n            );\n        END IF;\n        \n        -- Check if slot is in pending status\n        IF v_slot.status != 'pending' THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Slot is not in pending status',\n                'current_status', v_slot.status\n            );\n        END IF;\n        \n        -- Confirm the slot\n        UPDATE tournament_slots \n        SET \n            status = 'confirmed',\n            confirmed_at = NOW()\n        WHERE id = p_slot_id;\n        \n        -- Return success\n        RETURN json_build_object(\n            'success', true,\n            'message', 'Slot confirmed successfully',\n            'tournament_id', p_tournament_id,\n            'slot_id', p_slot_id,\n            'player_id', v_slot.player_id,\n            'slot_number', v_slot.slot_number,\n            'status', 'confirmed'\n        );\n        \n    EXCEPTION\n        WHEN OTHERS THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Failed to confirm slot: ' || SQLERRM,\n                'tournament_id', p_tournament_id,\n                'slot_id', p_slot_id\n            );\n    END;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "finalize_auction",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_user_id uuid DEFAULT auth.uid()",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_winning_bids JSON;\n    v_team_budget_updates JSON;\n    v_finalized_count INTEGER := 0;\n    v_total_budget_deducted DECIMAL(10,2) := 0;\n    v_result JSON;\n    v_bid JSON;\n    v_team RECORD;\n    v_existing_allocation RECORD;\n    v_bid_record RECORD;\nBEGIN\n    -- Start transaction\n    BEGIN\n        -- Validate tournament exists and is in correct status\n        SELECT * INTO v_tournament \n        FROM tournaments \n        WHERE id = p_tournament_id;\n        \n        IF NOT FOUND THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Tournament not found',\n                'tournament_id', p_tournament_id\n            );\n        END IF;\n        \n        -- Check if tournament is in auction_started status\n        IF v_tournament.status != 'auction_started' THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Tournament is not in auction_started status',\n                'current_status', v_tournament.status,\n                'tournament_id', p_tournament_id\n            );\n        END IF;\n        \n        -- Check if user has permission to finalize auction\n        -- Only tournament host or admin can finalize\n        IF NOT EXISTS (\n            SELECT 1 FROM users \n            WHERE id = p_user_id \n            AND (role = 'admin' OR id = v_tournament.host_id)\n        ) THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Insufficient permissions to finalize auction',\n                'user_id', p_user_id\n            );\n        END IF;\n        \n        -- Get all winning bids (highest bid per player) using a simpler approach\n        WITH winning_bids AS (\n            SELECT DISTINCT ON (ab.player_id)\n                ab.id as bid_id,\n                ab.tournament_id,\n                ab.player_id,\n                ab.team_id,\n                ab.bid_amount,\n                ab.bidder_user_id,\n                ab.created_at,\n                t.name as team_name,\n                t.budget_remaining,\n                p.display_name as player_name\n            FROM auction_bids ab\n            JOIN teams t ON ab.team_id = t.id\n            JOIN players p ON ab.player_id = p.id\n            WHERE ab.tournament_id = p_tournament_id\n            ORDER BY ab.player_id, ab.bid_amount DESC, ab.created_at ASC\n        )\n        SELECT COALESCE(\n            json_agg(\n                json_build_object(\n                    'bid_id', bid_id,\n                    'tournament_id', tournament_id,\n                    'player_id', player_id,\n                    'team_id', team_id,\n                    'bid_amount', bid_amount,\n                    'bidder_user_id', bidder_user_id,\n                    'team_name', team_name,\n                    'budget_remaining', budget_remaining,\n                    'player_name', player_name,\n                    'created_at', created_at\n                )\n            ), \n            '[]'::json\n        ) INTO v_winning_bids\n        FROM winning_bids;\n        \n        -- Check if there are any winning bids\n        IF v_winning_bids IS NULL OR json_array_length(v_winning_bids) = 0 THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'No winning bids found for this tournament',\n                'tournament_id', p_tournament_id\n            );\n        END IF;\n        \n        -- Validate that all teams have sufficient budget for their winning bids\n        FOR v_bid_record IN \n            SELECT * FROM json_to_recordset(v_winning_bids) AS x(\n                bid_id UUID,\n                tournament_id UUID,\n                player_id UUID,\n                team_id UUID,\n                bid_amount DECIMAL,\n                bidder_user_id UUID,\n                team_name TEXT,\n                budget_remaining DECIMAL,\n                player_name TEXT,\n                created_at TIMESTAMPTZ\n            )\n        LOOP\n            -- Check if team has sufficient budget\n            IF v_bid_record.budget_remaining IS NULL OR \n               v_bid_record.budget_remaining < v_bid_record.bid_amount THEN\n                RETURN json_build_object(\n                    'success', false,\n                    'error', 'Insufficient budget for team allocation',\n                    'team_id', v_bid_record.team_id,\n                    'team_name', v_bid_record.team_name,\n                    'required_amount', v_bid_record.bid_amount,\n                    'available_budget', v_bid_record.budget_remaining\n                );\n            END IF;\n        END LOOP;\n        \n        -- Clear existing team_players allocations for this tournament\n        DELETE FROM team_players \n        WHERE team_id IN (\n            SELECT id FROM teams WHERE tournament_id = p_tournament_id\n        );\n        \n        -- Process each winning bid\n        FOR v_bid_record IN \n            SELECT * FROM json_to_recordset(v_winning_bids) AS x(\n                bid_id UUID,\n                tournament_id UUID,\n                player_id UUID,\n                team_id UUID,\n                bid_amount DECIMAL,\n                bidder_user_id UUID,\n                team_name TEXT,\n                budget_remaining DECIMAL,\n                player_name TEXT,\n                created_at TIMESTAMPTZ\n            )\n        LOOP\n            -- Insert into team_players (final allocation)\n            INSERT INTO team_players (\n                team_id,\n                player_id,\n                final_bid_amount,\n                created_at\n            ) VALUES (\n                v_bid_record.team_id,\n                v_bid_record.player_id,\n                v_bid_record.bid_amount,\n                NOW()\n            );\n            \n            -- Update team budget\n            UPDATE teams \n            SET \n                budget_remaining = budget_remaining - v_bid_record.bid_amount,\n                updated_at = NOW()\n            WHERE id = v_bid_record.team_id;\n            \n            -- Update auction_bids to mark as winning\n            UPDATE auction_bids \n            SET is_winning_bid = TRUE\n            WHERE id = v_bid_record.bid_id;\n            \n            v_finalized_count := v_finalized_count + 1;\n            v_total_budget_deducted := v_total_budget_deducted + v_bid_record.bid_amount;\n        END LOOP;\n        \n        -- Update tournament status to auction_completed\n        UPDATE tournaments \n        SET \n            status = 'auction_completed',\n            updated_at = NOW()\n        WHERE id = p_tournament_id;\n        \n        -- Get final team budget summary\n        SELECT COALESCE(\n            json_agg(\n                json_build_object(\n                    'team_id', t.id,\n                    'team_name', t.name,\n                    'initial_budget', t.initial_budget,\n                    'budget_remaining', t.budget_remaining,\n                    'total_spent', t.initial_budget - t.budget_remaining,\n                    'players_count', (\n                        SELECT COUNT(*) \n                        FROM team_players tp \n                        WHERE tp.team_id = t.id\n                    )\n                )\n            ),\n            '[]'::json\n        ) INTO v_team_budget_updates\n        FROM teams t\n        WHERE t.tournament_id = p_tournament_id;\n        \n        -- Return comprehensive results\n        RETURN json_build_object(\n            'success', true,\n            'message', 'Auction finalized successfully',\n            'tournament_id', p_tournament_id,\n            'tournament_name', v_tournament.name,\n            'finalized_players', v_finalized_count,\n            'total_budget_deducted', v_total_budget_deducted,\n            'winning_bids', v_winning_bids,\n            'team_summaries', v_team_budget_updates,\n            'finalized_at', NOW()\n        );\n        \n    EXCEPTION\n        WHEN OTHERS THEN\n            -- Rollback on any error\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Failed to finalize auction: ' || SQLERRM,\n                'tournament_id', p_tournament_id,\n                'details', SQLSTATE\n            );\n    END;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "generate_username_from_email",
      "return_type": "text",
      "arguments": "email text",
      "source_code": "\nBEGIN\n  RETURN LOWER(SPLIT_PART(email, '@', 1));\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_api_usage_stats",
      "return_type": "TABLE(route text, method text, total_requests bigint, unique_users bigint, avg_response_time_ms numeric, success_rate numeric, total_errors bigint)",
      "arguments": "start_date timestamp with time zone DEFAULT (now() - '30 days'::interval), end_date timestamp with time zone DEFAULT now()",
      "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        aua.route,\n        aua.method,\n        COUNT(*) as total_requests,\n        COUNT(DISTINCT aua.user_id) as unique_users,\n        ROUND(AVG(aua.response_time_ms), 2) as avg_response_time_ms,\n        ROUND(\n            (COUNT(*) FILTER (WHERE aua.response_status >= 200 AND aua.response_status < 300))::NUMERIC / \n            COUNT(*)::NUMERIC * 100, 2\n        ) as success_rate,\n        COUNT(*) FILTER (WHERE aua.response_status >= 400) as total_errors\n    FROM public.api_usage_analytics aua\n    WHERE aua.created_at BETWEEN start_date AND end_date\n    GROUP BY aua.route, aua.method\n    ORDER BY total_requests DESC;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_auction_results",
      "return_type": "json",
      "arguments": "p_tournament_id uuid",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_results JSON;\nBEGIN\n    -- Get tournament details\n    SELECT * INTO v_tournament \n    FROM tournaments \n    WHERE id = p_tournament_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Tournament not found'\n        );\n    END IF;\n    \n    -- Get final auction results\n    SELECT COALESCE(\n        json_agg(\n            json_build_object(\n                'team_id', t.id,\n                'team_name', t.name,\n                'captain_name', p.display_name,\n                'initial_budget', t.initial_budget,\n                'budget_remaining', t.budget_remaining,\n                'total_spent', t.initial_budget - t.budget_remaining,\n                'players', (\n                    SELECT COALESCE(\n                        json_agg(\n                            json_build_object(\n                                'player_id', tp.player_id,\n                                'player_name', pl.display_name,\n                                'final_bid_amount', tp.final_bid_amount,\n                                'allocated_at', tp.created_at\n                            )\n                        ),\n                        '[]'::json\n                    )\n                    FROM team_players tp\n                    JOIN players pl ON tp.player_id = pl.id\n                    WHERE tp.team_id = t.id\n                )\n            )\n        ),\n        '[]'::json\n    ) INTO v_results\n    FROM teams t\n    LEFT JOIN players p ON t.captain_id = p.id\n    WHERE t.tournament_id = p_tournament_id;\n    \n    RETURN json_build_object(\n        'success', true,\n        'tournament_id', p_tournament_id,\n        'tournament_name', v_tournament.name,\n        'tournament_status', v_tournament.status,\n        'results', v_results,\n        'total_teams', COALESCE(json_array_length(v_results), 0)\n    );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_auction_status",
      "return_type": "json",
      "arguments": "p_tournament_id uuid",
      "source_code": "\nDECLARE\n    v_tournament_status VARCHAR(30);\n    v_active_bids JSON;\n    v_teams JSON;\n    v_result JSON;\nBEGIN\n    -- Get tournament status\n    SELECT status INTO v_tournament_status\n    FROM public.tournaments\n    WHERE id = p_tournament_id;\n    \n    -- Get active bids\n    SELECT json_agg(\n        json_build_object(\n            'player_id', player_id,\n            'team_id', team_id,\n            'bid_amount', bid_amount,\n            'bidder_user_id', bidder_user_id,\n            'is_winning_bid', is_winning_bid,\n            'created_at', created_at\n        )\n    ) INTO v_active_bids\n    FROM public.auction_bids\n    WHERE tournament_id = p_tournament_id\n    AND is_winning_bid = true;\n    \n    -- Get teams\n    SELECT json_agg(\n        json_build_object(\n            'team_id', id,\n            'name', name,\n            'captain_user_id', captain_user_id,\n            'budget_remaining', budget_remaining\n        )\n    ) INTO v_teams\n    FROM public.teams\n    WHERE tournament_id = p_tournament_id;\n    \n    -- Build result\n    v_result := json_build_object(\n        'tournament_id', p_tournament_id,\n        'status', v_tournament_status,\n        'active_bids', COALESCE(v_active_bids, '[]'::json),\n        'teams', COALESCE(v_teams, '[]'::json)\n    );\n    \n    RETURN v_result;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_hourly_usage_patterns",
      "return_type": "TABLE(hour_of_day integer, total_requests bigint, unique_users bigint, avg_response_time_ms numeric)",
      "arguments": "start_date timestamp with time zone DEFAULT (now() - '7 days'::interval), end_date timestamp with time zone DEFAULT now()",
      "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        EXTRACT(HOUR FROM aua.created_at)::INTEGER as hour_of_day,\n        COUNT(*) as total_requests,\n        COUNT(DISTINCT aua.user_id) as unique_users,\n        ROUND(AVG(aua.response_time_ms), 2) as avg_response_time_ms\n    FROM public.api_usage_analytics aua\n    WHERE aua.created_at BETWEEN start_date AND end_date\n    GROUP BY EXTRACT(HOUR FROM aua.created_at)\n    ORDER BY hour_of_day;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_recommended_slots",
      "return_type": "integer",
      "arguments": "tournament_format character varying",
      "source_code": "\nBEGIN\n  CASE tournament_format\n    WHEN 'Bilateral' THEN RETURN 22; -- 11 players per team * 2 teams\n    WHEN 'TriSeries' THEN RETURN 33; -- 11 players per team * 3 teams\n    WHEN 'Quad' THEN RETURN 44; -- 11 players per team * 4 teams\n    WHEN '6 Team' THEN RETURN 66; -- 11 players per team * 6 teams\n    WHEN '8 Team' THEN RETURN 88; -- 11 players per team * 8 teams\n    WHEN '10 Team' THEN RETURN 110; -- 11 players per team * 10 teams\n    WHEN '12 Team' THEN RETURN 132; -- 11 players per team * 12 teams\n    WHEN '16 Team' THEN RETURN 176; -- 11 players per team * 16 teams\n    WHEN '20 Team' THEN RETURN 220; -- 11 players per team * 20 teams\n    WHEN '24 Team' THEN RETURN 264; -- 11 players per team * 24 teams\n    WHEN '32 Team' THEN RETURN 352; -- 11 players per team * 32 teams\n    ELSE RETURN 88; -- Default to 8 teams worth of slots\n  END CASE;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_recommended_teams",
      "return_type": "integer",
      "arguments": "tournament_format character varying",
      "source_code": "\nBEGIN\n  CASE tournament_format\n    WHEN 'Bilateral' THEN RETURN 2;\n    WHEN 'TriSeries' THEN RETURN 3;\n    WHEN 'Quad' THEN RETURN 4;\n    WHEN '6 Team' THEN RETURN 6;\n    WHEN '8 Team' THEN RETURN 8;\n    WHEN '10 Team' THEN RETURN 10;\n    WHEN '12 Team' THEN RETURN 12;\n    WHEN '16 Team' THEN RETURN 16;\n    WHEN '20 Team' THEN RETURN 20;\n    WHEN '24 Team' THEN RETURN 24;\n    WHEN '32 Team' THEN RETURN 32;\n    ELSE RETURN 8; -- Default to 8 teams\n  END CASE;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_tournament_status",
      "return_type": "json",
      "arguments": "p_tournament_id uuid",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_slots_count INTEGER;\n    v_confirmed_count INTEGER;\n    v_pending_count INTEGER;\n    v_waitlist_count INTEGER;\nBEGIN\n    -- Get tournament details\n    SELECT * INTO v_tournament \n    FROM tournaments \n    WHERE id = p_tournament_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Tournament not found'\n        );\n    END IF;\n    \n    -- Count slots by status\n    SELECT \n        COUNT(*) as total_slots,\n        COUNT(CASE WHEN status = 'confirmed' THEN 1 END) as confirmed_slots,\n        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_slots\n    INTO v_slots_count, v_confirmed_count, v_pending_count\n    FROM tournament_slots \n    WHERE tournament_id = p_tournament_id;\n    \n    -- Count waitlist\n    SELECT COUNT(*) INTO v_waitlist_count\n    FROM waitlist \n    WHERE tournament_id = p_tournament_id;\n    \n    RETURN json_build_object(\n        'success', true,\n        'tournament_id', p_tournament_id,\n        'tournament_name', v_tournament.name,\n        'status', v_tournament.status,\n        'total_slots', v_tournament.total_slots,\n        'filled_slots', v_slots_count,\n        'confirmed_slots', v_confirmed_count,\n        'pending_slots', v_pending_count,\n        'available_slots', v_tournament.total_slots - v_slots_count,\n        'waitlist_count', v_waitlist_count,\n        'is_full', v_slots_count >= v_tournament.total_slots\n    );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_user_activity_stats",
      "return_type": "TABLE(user_id uuid, user_email text, user_role text, total_requests bigint, unique_routes bigint, last_activity timestamp with time zone, avg_response_time_ms numeric)",
      "arguments": "start_date timestamp with time zone DEFAULT (now() - '30 days'::interval), end_date timestamp with time zone DEFAULT now()",
      "source_code": "\nBEGIN\n    RETURN QUERY\n    SELECT \n        aua.user_id,\n        u.email as user_email,\n        aua.user_role,\n        COUNT(*) as total_requests,\n        COUNT(DISTINCT aua.route) as unique_routes,\n        MAX(aua.created_at) as last_activity,\n        ROUND(AVG(aua.response_time_ms), 2) as avg_response_time_ms\n    FROM public.api_usage_analytics aua\n    LEFT JOIN public.users u ON aua.user_id = u.id\n    WHERE aua.created_at BETWEEN start_date AND end_date\n    AND aua.user_id IS NOT NULL\n    GROUP BY aua.user_id, u.email, aua.user_role\n    ORDER BY total_requests DESC;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_user_display_name",
      "return_type": "text",
      "arguments": "user_record users",
      "source_code": "\nBEGIN\n  IF user_record.username IS NOT NULL AND user_record.username != '' THEN\n    RETURN user_record.username;\n  ELSE\n    RETURN get_user_full_name(user_record);\n  END IF;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "get_user_full_name",
      "return_type": "text",
      "arguments": "user_record users",
      "source_code": "\nBEGIN\n  RETURN CONCAT_WS(' ', \n    user_record.firstname,\n    COALESCE(user_record.middlename, ''),\n    user_record.lastname\n  );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "is_admin",
      "return_type": "boolean",
      "arguments": "user_id uuid",
      "source_code": "\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM users \n    WHERE id = user_id AND role = 'admin'\n  );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "is_team_captain",
      "return_type": "boolean",
      "arguments": "team_id uuid, user_id uuid",
      "source_code": "\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM teams \n    WHERE id = team_id AND captain_user_id = user_id\n  );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "is_tournament_host",
      "return_type": "boolean",
      "arguments": "tournament_id uuid, user_id uuid",
      "source_code": "\nBEGIN\n  RETURN EXISTS (\n    SELECT 1 FROM tournaments \n    WHERE id = tournament_id AND host_id = user_id\n  );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "manual_promote_waitlist",
      "return_type": "TABLE(promoted_player_id uuid, new_slot_number integer, success boolean)",
      "arguments": "p_tournament_id uuid",
      "source_code": "\nDECLARE\n    v_total_slots INTEGER;\n    v_first_waitlist_player RECORD;\n    v_empty_main_slot INTEGER;\nBEGIN\n    -- Get tournament total slots\n    SELECT total_slots INTO v_total_slots\n    FROM tournaments \n    WHERE id = p_tournament_id;\n    \n    -- Find the first empty main slot\n    SELECT MIN(slot_number) INTO v_empty_main_slot\n    FROM tournament_slots\n    WHERE tournament_id = p_tournament_id\n      AND slot_number <= v_total_slots\n      AND player_id IS NULL;\n    \n    -- If no empty main slot, return failure\n    IF v_empty_main_slot IS NULL THEN\n        RETURN QUERY SELECT NULL::UUID, NULL::INTEGER, FALSE;\n        RETURN;\n    END IF;\n    \n    -- Find the first waitlist player\n    SELECT * INTO v_first_waitlist_player\n    FROM tournament_slots\n    WHERE tournament_id = p_tournament_id\n      AND slot_number > v_total_slots\n      AND player_id IS NOT NULL\n      AND status = 'waitlist'\n    ORDER BY requested_at ASC\n    LIMIT 1;\n    \n    -- If no waitlist player, return failure\n    IF v_first_waitlist_player IS NULL THEN\n        RETURN QUERY SELECT NULL::UUID, NULL::INTEGER, FALSE;\n        RETURN;\n    END IF;\n    \n    -- Promote the waitlist player\n    UPDATE tournament_slots\n    SET slot_number = v_empty_main_slot,\n        status = 'pending',\n        updated_at = NOW()\n    WHERE id = v_first_waitlist_player.id;\n    \n    -- Return success\n    RETURN QUERY SELECT v_first_waitlist_player.player_id, v_empty_main_slot, TRUE;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "mark_all_notifications_read",
      "return_type": "integer",
      "arguments": "p_user_id uuid",
      "source_code": "\nDECLARE\n    v_updated_count INTEGER;\nBEGIN\n    UPDATE notifications\n    SET read_at = NOW(),\n        updated_at = NOW()\n    WHERE user_id = p_user_id\n      AND read_at IS NULL;\n    \n    GET DIAGNOSTICS v_updated_count = ROW_COUNT;\n    RETURN v_updated_count;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "mark_notification_read",
      "return_type": "boolean",
      "arguments": "p_notification_id uuid",
      "source_code": "\nBEGIN\n    UPDATE notifications\n    SET read_at = NOW(),\n        updated_at = NOW()\n    WHERE id = p_notification_id\n      AND user_id = auth.uid();\n    \n    RETURN FOUND;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "place_bid",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_player_id uuid, p_team_id uuid, p_bid_amount numeric",
      "source_code": "\nDECLARE\n    v_bidder_user_id UUID;\n    v_current_winning_bid DECIMAL(10,2);\n    v_min_increment DECIMAL(10,2);\n    v_tournament_status VARCHAR(30);\n    v_is_captain BOOLEAN;\n    v_team_budget DECIMAL(10,2);\n    v_bid_id UUID;\n    v_result JSON;\nBEGIN\n    -- Get the authenticated user\n    v_bidder_user_id := auth.uid();\n    \n    -- Validate user is authenticated\n    IF v_bidder_user_id IS NULL THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'User not authenticated'\n        );\n    END IF;\n    \n    -- Check if user is captain of the team\n    SELECT captain_user_id = v_bidder_user_id, budget_remaining\n    INTO v_is_captain, v_team_budget\n    FROM public.teams\n    WHERE id = p_team_id;\n    \n    IF NOT v_is_captain THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Only team captains can place bids'\n        );\n    END IF;\n    \n    -- Check tournament status\n    SELECT status, min_increment\n    INTO v_tournament_status, v_min_increment\n    FROM public.tournaments\n    WHERE id = p_tournament_id;\n    \n    IF v_tournament_status != 'auction_started' THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Auction is not active'\n        );\n    END IF;\n    \n    -- Get current winning bid for this player\n    SELECT COALESCE(MAX(bid_amount), 0)\n    INTO v_current_winning_bid\n    FROM public.auction_bids\n    WHERE tournament_id = p_tournament_id \n    AND player_id = p_player_id \n    AND is_winning_bid = true;\n    \n    -- Validate bid amount\n    IF p_bid_amount <= v_current_winning_bid THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Bid amount must be higher than current winning bid',\n            'current_bid', v_current_winning_bid\n        );\n    END IF;\n    \n    -- Check minimum increment\n    IF v_min_increment IS NOT NULL AND p_bid_amount < (v_current_winning_bid + v_min_increment) THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Bid must be at least ' || v_min_increment || ' higher than current bid',\n            'required_amount', v_current_winning_bid + v_min_increment\n        );\n    END IF;\n    \n    -- Check team budget\n    IF p_bid_amount > v_team_budget THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Bid exceeds team budget',\n            'available_budget', v_team_budget\n        );\n    END IF;\n    \n    -- Start transaction for atomic operations\n    BEGIN\n        -- Mark all previous bids for this player as not winning\n        UPDATE public.auction_bids\n        SET is_winning_bid = false\n        WHERE tournament_id = p_tournament_id \n        AND player_id = p_player_id;\n        \n        -- Insert new bid\n        INSERT INTO public.auction_bids (\n            tournament_id,\n            player_id,\n            team_id,\n            bid_amount,\n            bidder_user_id,\n            is_winning_bid\n        ) VALUES (\n            p_tournament_id,\n            p_player_id,\n            p_team_id,\n            p_bid_amount,\n            v_bidder_user_id,\n            true\n        ) RETURNING id INTO v_bid_id;\n        \n        -- Update team budget\n        UPDATE public.teams\n        SET budget_remaining = budget_remaining - p_bid_amount\n        WHERE id = p_team_id;\n        \n        -- Return success\n        RETURN json_build_object(\n            'success', true,\n            'bid_id', v_bid_id,\n            'bid_amount', p_bid_amount,\n            'team_budget_remaining', v_team_budget - p_bid_amount,\n            'message', 'Bid placed successfully'\n        );\n        \n    EXCEPTION\n        WHEN OTHERS THEN\n            -- Rollback on any error\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Database error: ' || SQLERRM\n            );\n    END;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "register_player",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_player_id uuid, p_preferred_slot integer DEFAULT NULL::integer, p_user_id uuid DEFAULT auth.uid()",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_player RECORD;\n    v_result JSON;\n    v_slot_id UUID;\nBEGIN\n    -- Start transaction\n    BEGIN\n        -- Validate tournament exists and is accepting registrations\n        SELECT * INTO v_tournament \n        FROM tournaments \n        WHERE id = p_tournament_id \n        AND status = 'registration_open';\n        \n        IF NOT FOUND THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Tournament not found or not accepting registrations',\n                'tournament_id', p_tournament_id\n            );\n        END IF;\n        \n        -- Validate player exists\n        SELECT * INTO v_player \n        FROM players \n        WHERE id = p_player_id;\n        \n        IF NOT FOUND THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Player not found',\n                'player_id', p_player_id\n            );\n        END IF;\n        \n        -- Check if player is already registered\n        IF EXISTS (\n            SELECT 1 FROM tournament_slots \n            WHERE tournament_id = p_tournament_id \n            AND player_id = p_player_id\n        ) THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Player is already registered in this tournament',\n                'player_id', p_player_id\n            );\n        END IF;\n        \n        -- Use reserve_slot function to handle the registration\n        SELECT reserve_slot(p_tournament_id, p_player_id, p_preferred_slot, p_user_id) INTO v_result;\n        \n        -- Return the result from reserve_slot\n        RETURN v_result;\n        \n    EXCEPTION\n        WHEN OTHERS THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Failed to register player: ' || SQLERRM,\n                'tournament_id', p_tournament_id,\n                'player_id', p_player_id\n            );\n    END;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "reserve_slot",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_player_id uuid, p_slot_number integer DEFAULT NULL::integer, p_user_id uuid DEFAULT auth.uid()",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_slot RECORD;\n    v_available_slot RECORD;\n    v_result JSON;\n    v_slot_id UUID;\nBEGIN\n    -- Start transaction\n    BEGIN\n        -- Validate tournament exists and is in registration phase\n        SELECT * INTO v_tournament \n        FROM tournaments \n        WHERE id = p_tournament_id \n        AND status IN ('registration_open', 'registration_closed');\n        \n        IF NOT FOUND THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Tournament not found or not accepting registrations',\n                'tournament_id', p_tournament_id\n            );\n        END IF;\n        \n        -- Check if player is already registered in this tournament\n        IF EXISTS (\n            SELECT 1 FROM tournament_slots \n            WHERE tournament_id = p_tournament_id \n            AND player_id = p_player_id \n            AND status IN ('pending', 'confirmed')\n        ) THEN\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Player is already registered in this tournament',\n                'player_id', p_player_id\n            );\n        END IF;\n        \n        -- If specific slot number provided, check if it's available\n        IF p_slot_number IS NOT NULL THEN\n            SELECT * INTO v_slot \n            FROM tournament_slots \n            WHERE tournament_id = p_tournament_id \n            AND slot_number = p_slot_number;\n            \n            IF FOUND AND v_slot.status != 'empty' THEN\n                RETURN json_build_object(\n                    'success', false,\n                    'error', 'Requested slot is not available',\n                    'slot_number', p_slot_number,\n                    'current_status', v_slot.status\n                );\n            END IF;\n            \n            -- Reserve the specific slot\n            IF FOUND THEN\n                UPDATE tournament_slots \n                SET \n                    player_id = p_player_id,\n                    status = 'pending',\n                    requested_at = NOW()\n                WHERE tournament_id = p_tournament_id \n                AND slot_number = p_slot_number\n                RETURNING id INTO v_slot_id;\n            ELSE\n                -- Create new slot if it doesn't exist\n                INSERT INTO tournament_slots (\n                    tournament_id, slot_number, player_id, status, requested_at\n                ) VALUES (\n                    p_tournament_id, p_slot_number, p_player_id, 'pending', NOW()\n                ) RETURNING id INTO v_slot_id;\n            END IF;\n        ELSE\n            -- Find first available slot\n            SELECT * INTO v_available_slot\n            FROM tournament_slots \n            WHERE tournament_id = p_tournament_id \n            AND status = 'empty'\n            ORDER BY slot_number\n            LIMIT 1\n            FOR UPDATE; -- Lock the row to prevent race conditions\n            \n            IF FOUND THEN\n                -- Reserve the first available slot\n                UPDATE tournament_slots \n                SET \n                    player_id = p_player_id,\n                    status = 'pending',\n                    requested_at = NOW()\n                WHERE id = v_available_slot.id\n                RETURNING id INTO v_slot_id;\n            ELSE\n                -- Check if we can create a new slot\n                IF (SELECT COUNT(*) FROM tournament_slots WHERE tournament_id = p_tournament_id) < v_tournament.total_slots THEN\n                    -- Create new slot\n                    INSERT INTO tournament_slots (\n                        tournament_id, \n                        slot_number, \n                        player_id, \n                        status, \n                        requested_at\n                    ) VALUES (\n                        p_tournament_id, \n                        (SELECT COALESCE(MAX(slot_number), 0) + 1 FROM tournament_slots WHERE tournament_id = p_tournament_id),\n                        p_player_id, \n                        'pending', \n                        NOW()\n                    ) RETURNING id INTO v_slot_id;\n                ELSE\n                    -- Tournament is full, add to waitlist\n                    INSERT INTO waitlist (tournament_id, player_id, position)\n                    VALUES (\n                        p_tournament_id, \n                        p_player_id, \n                        (SELECT COALESCE(MAX(position), 0) + 1 FROM waitlist WHERE tournament_id = p_tournament_id)\n                    );\n                    \n                    RETURN json_build_object(\n                        'success', true,\n                        'message', 'Tournament is full. Player added to waitlist.',\n                        'tournament_id', p_tournament_id,\n                        'player_id', p_player_id,\n                        'waitlist_position', (SELECT MAX(position) FROM waitlist WHERE tournament_id = p_tournament_id)\n                    );\n                END IF;\n            END IF;\n        END IF;\n        \n        -- Return success with slot details\n        RETURN json_build_object(\n            'success', true,\n            'message', 'Slot reserved successfully',\n            'tournament_id', p_tournament_id,\n            'player_id', p_player_id,\n            'slot_id', v_slot_id,\n            'slot_number', p_slot_number,\n            'status', 'pending'\n        );\n        \n    EXCEPTION\n        WHEN OTHERS THEN\n            -- Rollback on any error\n            RETURN json_build_object(\n                'success', false,\n                'error', 'Failed to reserve slot: ' || SQLERRM,\n                'tournament_id', p_tournament_id,\n                'player_id', p_player_id\n            );\n    END;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "reset_auction",
      "return_type": "json",
      "arguments": "p_tournament_id uuid, p_user_id uuid DEFAULT auth.uid()",
      "source_code": "\nDECLARE\n    v_tournament RECORD;\n    v_reset_count INTEGER := 0;\nBEGIN\n    -- Validate tournament exists\n    SELECT * INTO v_tournament \n    FROM tournaments \n    WHERE id = p_tournament_id;\n    \n    IF NOT FOUND THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Tournament not found'\n        );\n    END IF;\n    \n    -- Check if user has permission (admin or host)\n    IF NOT EXISTS (\n        SELECT 1 FROM users \n        WHERE id = p_user_id \n        AND (role = 'admin' OR id = v_tournament.host_id)\n    ) THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Insufficient permissions to reset auction'\n        );\n    END IF;\n    \n    -- Reset tournament status\n    UPDATE tournaments \n    SET \n        status = 'auction_started',\n        updated_at = NOW()\n    WHERE id = p_tournament_id;\n    \n    -- Clear team_players allocations\n    DELETE FROM team_players \n    WHERE team_id IN (\n        SELECT id FROM teams WHERE tournament_id = p_tournament_id\n    );\n    \n    -- Reset team budgets\n    UPDATE teams \n    SET \n        budget_remaining = initial_budget,\n        updated_at = NOW()\n    WHERE tournament_id = p_tournament_id;\n    \n    -- Clear winning bid flags\n    UPDATE auction_bids \n    SET is_winning_bid = FALSE\n    WHERE tournament_id = p_tournament_id;\n    \n    RETURN json_build_object(\n        'success', true,\n        'message', 'Auction reset successfully',\n        'tournament_id', p_tournament_id,\n        'reset_at', NOW()\n    );\n    \nEXCEPTION\n    WHEN OTHERS THEN\n        RETURN json_build_object(\n            'success', false,\n            'error', 'Failed to reset auction: ' || SQLERRM\n        );\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "sync_auth_user",
      "return_type": "trigger",
      "arguments": "",
      "source_code": "\nBEGIN\n  -- Insert or update user in public.users\n  INSERT INTO public.users (\n    id,\n    email,\n    username,\n    firstname,\n    middlename,\n    lastname,\n    photo,\n    role,\n    created_at,\n    updated_at\n  ) VALUES (\n    NEW.id,\n    NEW.email,\n    COALESCE(NEW.raw_user_meta_data->>'username', generate_username_from_email(NEW.email)),\n    COALESCE(NEW.raw_user_meta_data->>'firstname', ''),\n    NEW.raw_user_meta_data->>'middlename',\n    COALESCE(NEW.raw_user_meta_data->>'lastname', ''),\n    NEW.raw_user_meta_data->>'photo',\n    COALESCE(NEW.raw_user_meta_data->>'role', 'viewer'),\n    NEW.created_at,\n    NEW.updated_at\n  )\n  ON CONFLICT (id) DO UPDATE SET\n    email = EXCLUDED.email,\n    username = COALESCE(EXCLUDED.username, users.username),\n    firstname = COALESCE(EXCLUDED.firstname, users.firstname),\n    middlename = COALESCE(EXCLUDED.middlename, users.middlename),\n    lastname = COALESCE(EXCLUDED.lastname, users.lastname),\n    photo = COALESCE(EXCLUDED.photo, users.photo),\n    role = COALESCE(EXCLUDED.role, users.role),\n    updated_at = EXCLUDED.updated_at;\n  \n  RETURN NEW;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    },
    {
      "function_name": "validate_tournament_data",
      "return_type": "boolean",
      "arguments": "p_format character varying, p_selected_teams integer, p_total_slots integer",
      "source_code": "\nBEGIN\n  -- Check if format is valid\n  IF p_format NOT IN ('Bilateral', 'TriSeries', 'Quad', '6 Team', '8 Team', '10 Team', '12 Team', '16 Team', '20 Team', '24 Team', '32 Team') THEN\n    RETURN FALSE;\n  END IF;\n  \n  -- Check if selected teams matches format\n  IF p_selected_teams != get_recommended_teams(p_format) THEN\n    RETURN FALSE;\n  END IF;\n  \n  -- Check if total slots matches format\n  IF p_total_slots != get_recommended_slots(p_format) THEN\n    RETURN FALSE;\n  END IF;\n  \n  RETURN TRUE;\nEND;\n",
      "function_kind": "f",
      "language": "plpgsql"
    }
  ]